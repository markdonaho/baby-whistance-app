import 'dart:async';

import 'package:baby_whistance_app/features/auth/application/auth_controller.dart';
import 'package:baby_whistance_app/features/auth/application/auth_providers.dart';
import 'package:baby_whistance_app/features/auth/domain/repositories/auth_repository.dart';
// No AppUser needed here for AuthController state as it deals with firebase_auth.User
// import 'package:baby_whistance_app/shared/models/app_user.dart'; 
import 'package:firebase_auth/firebase_auth.dart' as firebase_auth;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Generate mocks for AuthRepository, firebase_auth.User, and firebase_auth.UserCredential
@GenerateMocks([
  AuthRepository,
  firebase_auth.User,
  firebase_auth.UserCredential,
])
import 'auth_controller_test.mocks.dart'; // This will be generated by build_runner

void main() {
  // Mocks
  late MockAuthRepository mockAuthRepository;
  late MockUser mockFirebaseUser; // For firebase_auth.User
  late MockUserCredential mockUserCredential; // For firebase_auth.UserCredential

  // ProviderContainer for testing Riverpod providers
  late ProviderContainer container;
  // AuthController instance, obtained from the container
  late AuthController authControllerNotifier;

  // Test data
  const tEmail = 'test@example.com';
  const tPassword = 'password123';
  const tDisplayName = 'Test User';
  const tUid = 'test_uid';

  setUp(() {
    mockAuthRepository = MockAuthRepository();
    mockFirebaseUser = MockUser();
    mockUserCredential = MockUserCredential();

    // Configure mockFirebaseUser
    when(mockFirebaseUser.uid).thenReturn(tUid);
    when(mockFirebaseUser.email).thenReturn(tEmail);
    when(mockFirebaseUser.displayName).thenReturn(tDisplayName);
    when(mockFirebaseUser.emailVerified).thenReturn(false); // Default to not verified
    when(mockFirebaseUser.reload()).thenAnswer((_) async {});
    // According to AuthRepository, User.sendEmailVerification is not directly called by controller.
    // The repository has its own sendEmailVerification method.

    // Configure mockUserCredential to return our mockFirebaseUser
    when(mockUserCredential.user).thenReturn(mockFirebaseUser);

    // Initialize ProviderContainer with overrides for dependencies
    container = ProviderContainer(
      overrides: [
        authRepositoryProvider.overrideWithValue(mockAuthRepository),
        authStateChangesProvider.overrideWith((ref) => Stream.value(null)), // Default to logged out
      ],
    );

    // Get the AuthController notifier instance from the container.
    // The initial build method of AuthController will run here based on the initial authStateChangesProvider stream.
    authControllerNotifier = container.read(authControllerProvider.notifier);
  });

  tearDown(() {
    container.dispose();
  });

  // Helper to re-initialize container with a specific auth state stream
  void reinitializeContainerAndController({Stream<firebase_auth.User?>? authStateStream}) {
    container.dispose(); // Dispose old one to ensure fresh state and overrides
    container = ProviderContainer(
      overrides: [
        authRepositoryProvider.overrideWithValue(mockAuthRepository),
        if (authStateStream != null)
          authStateChangesProvider.overrideWith((ref) => authStateStream)
        else
          authStateChangesProvider.overrideWith((ref) => Stream.value(null)),
      ],
    );
    // This ensures the AuthController's build method re-evaluates with the new stream
    authControllerNotifier = container.read(authControllerProvider.notifier);
  }

  // Listener for verifying state changes in order
  Listener<AsyncValue<firebase_auth.User?>> arrangeListener() {
    final listener = Listener<AsyncValue<firebase_auth.User?>>();
    container.listen(authControllerProvider, listener, fireImmediately: true);
    return listener;
  }

  group('AuthController Initialization (build method via authStateChangesProvider)', () {
    test('initial state is AsyncData(null) when authStateChangesProvider emits null', () async {
      // Arrange: Default setup already has authStateChangesProvider emitting null.
      // Re-initialize to be explicit and ensure build() runs.
      reinitializeContainerAndController(authStateStream: Stream.value(null));
      
      // Act: Read the state. The build method of AuthController runs upon instantiation.
      final initialState = container.read(authControllerProvider);

      // Assert
      expect(initialState, const AsyncValue<firebase_auth.User?>.data(null));
    });

    test('state becomes AsyncData(User) when authStateChangesProvider emits a User', () async {
      // Arrange
      when(mockFirebaseUser.emailVerified).thenReturn(true);
      final userStream = Stream<firebase_auth.User?>.value(mockFirebaseUser);
      reinitializeContainerAndController(authStateStream: userStream);
      
      // Act: Wait for the provider to process the stream emission.
      // The AuthController's build method will react to this stream.
      await container.pump(); // Ensures the stream event is processed if needed.
      final userState = container.read(authControllerProvider);

      // Assert
      expect(userState, isA<AsyncData<firebase_auth.User?>>());
      expect(userState.value, mockFirebaseUser);
      expect(userState.value?.uid, tUid);
    });
  });

  group('signUpWithEmailAndPassword', () {
    test('sets state to loading, then AsyncData(User) from UserCredential on successful signup', () async {
      // Arrange
      when(mockAuthRepository.signUpWithEmailAndPassword(
        email: tEmail,
        password: tPassword,
        displayName: tDisplayName,
      )).thenAnswer((_) async => mockUserCredential); // Repo returns UserCredential
      // mockUserCredential.user is already stubbed to return mockFirebaseUser in setUp
      
      final listener = arrangeListener();
      // Remove initial fire if not relevant or verify it. Default setup is AsyncData(null).
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);

      // Act
      await authControllerNotifier.signUpWithEmailAndPassword(tEmail, tPassword, tDisplayName);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()), // First state change: loading
        listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser)), // Second state change: data from guard
      ]);
      verify(mockAuthRepository.signUpWithEmailAndPassword(
          email: tEmail, password: tPassword, displayName: tDisplayName)).called(1);
      expect(container.read(authControllerProvider).value, mockFirebaseUser);
    });

    test('sets state to AsyncError on signup failure (repository throws)', () async {
      // Arrange
      final exception = firebase_auth.FirebaseAuthException(code: 'weak-password');
      when(mockAuthRepository.signUpWithEmailAndPassword(
        email: tEmail,
        password: tPassword,
        displayName: tDisplayName,
      )).thenThrow(exception);

      final listener = arrangeListener();
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);

      // Act
      await authControllerNotifier.signUpWithEmailAndPassword(tEmail, tPassword, tDisplayName);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error, 'error', exception)),
      ]);
      expect(container.read(authControllerProvider).error, exception);
    });

    test('sets state to AsyncError if repository returns null UserCredential', () async {
      // Arrange
      when(mockAuthRepository.signUpWithEmailAndPassword(
        email: tEmail,
        password: tPassword,
        displayName: tDisplayName,
      )).thenAnswer((_) async => null); // Repository returns null UserCredential

      final listener = arrangeListener();
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);

      // Act
      await authControllerNotifier.signUpWithEmailAndPassword(tEmail, tPassword, tDisplayName);
      
      // Assert: AsyncValue.guard will catch the null return from `userCredential?.user` if userCredential is null
      // This results in an error state, typically a NullThrownError or similar if not handled explicitly inside guard.
      // Given the code `return userCredential?.user;`, if userCredential is null, `null?.user` is null.
      // AsyncValue.guard might treat a null return from its callback as an error if the type is non-nullable Future<User>.
      // Since it's Future<User?>, a null might be valid data. Let's test for AsyncData(null).
      // The print statement in controller: Final state: User: ${state.value?.uid}
      // If `userCredential` is null, `userCredential?.user` is null. So state.value will be null.
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, const AsyncData<firebase_auth.User?>(null)), // Because User? is nullable
      ]);
      expect(container.read(authControllerProvider).value, null);
      expect(container.read(authControllerProvider).hasError, false);
    });
  });

  group('signInWithEmailAndPassword', () {
    test('sets state to loading, then AsyncData(User) and returns User on successful signin', () async {
      // Arrange
      when(mockAuthRepository.signInWithEmailAndPassword(email: tEmail, password: tPassword))
          .thenAnswer((_) async => mockFirebaseUser);
      
      final listener = arrangeListener();
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);

      // Act
      final resultUser = await authControllerNotifier.signInWithEmailAndPassword(tEmail, tPassword);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser)),
      ]);
      verify(mockAuthRepository.signInWithEmailAndPassword(email: tEmail, password: tPassword)).called(1);
      expect(resultUser, mockFirebaseUser);
      expect(container.read(authControllerProvider).value, mockFirebaseUser);
    });

    test('sets state to AsyncError and returns null on signin failure (repo throws)', () async {
      // Arrange
      final exception = firebase_auth.FirebaseAuthException(code: 'user-not-found');
      when(mockAuthRepository.signInWithEmailAndPassword(email: tEmail, password: tPassword))
          .thenThrow(exception);

      final listener = arrangeListener();
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);

      // Act
      final resultUser = await authControllerNotifier.signInWithEmailAndPassword(tEmail, tPassword);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error, 'error', exception)),
      ]);
      expect(resultUser, isNull);
      expect(container.read(authControllerProvider).error, exception);
    });

    test('sets state to AsyncError (custom message) and returns null if repo returns null user', () async {
      // Arrange
      when(mockAuthRepository.signInWithEmailAndPassword(email: tEmail, password: tPassword))
          .thenAnswer((_) async => null); // Repository returns null

      final listener = arrangeListener();
      verify(listener(any, const AsyncData<firebase_auth.User?>(null))).called(1);
      
      // Act
      final resultUser = await authControllerNotifier.signInWithEmailAndPassword(tEmail, tPassword);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error.toString(), 'error message', contains("Login failed"))),
      ]);
      expect(resultUser, isNull);
      expect(container.read(authControllerProvider).hasError, true);
    });
  });

  group('signOut', () {
    test('sets state to loading, then AsyncData(null) on successful signout', () async {
      // Arrange: Start with a logged-in user to see the change
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump(); // Ensure the build method processes the initial user state
      expect(container.read(authControllerProvider).value, mockFirebaseUser, reason: "Controller should have initial user from stream");

      when(mockAuthRepository.signOut()).thenAnswer((_) async {});
      
      final listener = arrangeListener();
      // Listener is fired immediately with current state (AsyncData(mockFirebaseUser))
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      await authControllerNotifier.signOut();

      // Assert
      verifyInOrder([
        // listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser)), // Initial state before action if not cleared
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, const AsyncData<firebase_auth.User?>(null)),
      ]);
      verify(mockAuthRepository.signOut()).called(1);
      expect(container.read(authControllerProvider).value, isNull);
    });

    // If mockAuthRepository.signOut() throws, the current AuthController signOut method
    // does not catch the error. The state would remain AsyncLoading, and the error
    // would propagate. A more robust controller might catch this.
    // Test for this behavior:
    test('state remains loading and error propagates if repository.signOut throws', () async {
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump();
      expect(container.read(authControllerProvider).value, mockFirebaseUser);

      final exception = Exception('Sign out failed in repo');
      when(mockAuthRepository.signOut()).thenThrow(exception);

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);
      
      // Act & Assert for propagated exception
      expect(() => authControllerNotifier.signOut(), throwsA(exception));
      
      // Check state sequence
      verify(listener(any, const AsyncLoading<firebase_auth.User?>())).called(1);
      
      // After throw, the state might still be loading as it was set before the await that threw.
      // The error is not caught and converted to AsyncError by this specific controller method.
      final currentState = container.read(authControllerProvider);
      expect(currentState, isA<AsyncLoading>());
    });
  });

  group('sendEmailVerification', () {
    test('sets loading, then AsyncData(currentUser) on success', () async {
      // Arrange: Start with a logged-in user (state of controller reflects this)
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump();
      expect(container.read(authControllerProvider).value, mockFirebaseUser);
      
      when(mockAuthRepository.sendEmailVerification()).thenAnswer((_) async {});

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      await authControllerNotifier.sendEmailVerification();

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser)), // Resets to current user state
      ]);
      verify(mockAuthRepository.sendEmailVerification()).called(1);
      expect(container.read(authControllerProvider).value, mockFirebaseUser);
    });

    test('sets state to AsyncError on repository failure', () async {
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump();

      final exception = Exception('Failed to send email via repo');
      when(mockAuthRepository.sendEmailVerification()).thenThrow(exception);

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      await authControllerNotifier.sendEmailVerification();

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error, 'error', exception)),
      ]);
      expect(container.read(authControllerProvider).error, exception);
    });
  });

  group('checkIsEmailVerified', () {
    test('sets loading, updates state with reloaded user, returns true if email becomes verified', () async {
      // Arrange: Simulate a user whose emailVerified status changes upon reload.
      final initiallyUnverifiedUser = MockUser();
      when(initiallyUnverifiedUser.uid).thenReturn(tUid);
      when(initiallyUnverifiedUser.emailVerified).thenReturn(false);
      when(initiallyUnverifiedUser.reload()).thenAnswer((_) async {}); // Needed if User.reload() is called by repo

      final reloadedVerifiedUser = MockUser(); // This mock will be returned by reloadCurrentUser
      when(reloadedVerifiedUser.uid).thenReturn(tUid);
      when(reloadedVerifiedUser.emailVerified).thenReturn(true);

      reinitializeContainerAndController(authStateStream: Stream.value(initiallyUnverifiedUser));
      await container.pump();
      expect(container.read(authControllerProvider).value, initiallyUnverifiedUser);
      
      when(mockAuthRepository.reloadCurrentUser()).thenAnswer((_) async => reloadedVerifiedUser);

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(initiallyUnverifiedUser))).called(1);

      // Act
      final isVerified = await authControllerNotifier.checkIsEmailVerified();

      // Assert
      expect(isVerified, isTrue);
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, AsyncData<firebase_auth.User?>(reloadedVerifiedUser)),
      ]);
      verify(mockAuthRepository.reloadCurrentUser()).called(1);
      expect(container.read(authControllerProvider).value, reloadedVerifiedUser);
    });

    test('sets loading, updates state, returns false if email still not verified after reload', () async {
      // Arrange
      when(mockFirebaseUser.emailVerified).thenReturn(false); // Ensure it's consistently false
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump();

      when(mockAuthRepository.reloadCurrentUser()).thenAnswer((_) async => mockFirebaseUser); // Returns same unverified user

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      final isVerified = await authControllerNotifier.checkIsEmailVerified();

      // Assert
      expect(isVerified, isFalse);
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser)),
      ]);
      expect(container.read(authControllerProvider).value?.emailVerified, isFalse);
    });

    test('sets state to AsyncData(null) and returns false if reloadCurrentUser returns null', () async {
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser)); // Start logged in
      await container.pump();

      when(mockAuthRepository.reloadCurrentUser()).thenAnswer((_) async => null); // Reload returns null

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      final isVerified = await authControllerNotifier.checkIsEmailVerified();

      // Assert
      expect(isVerified, isFalse);
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, const AsyncData<firebase_auth.User?>(null)),
      ]);
      expect(container.read(authControllerProvider).value, isNull);
    });

    test('sets state to AsyncError and returns false on repository failure for reloadCurrentUser', () async {
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser));
      await container.pump();

      final exception = Exception('Failed to reload user in repo');
      when(mockAuthRepository.reloadCurrentUser()).thenThrow(exception);

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      final isVerified = await authControllerNotifier.checkIsEmailVerified();

      // Assert
      expect(isVerified, isFalse);
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error, 'error', exception)),
      ]);
      expect(container.read(authControllerProvider).error, exception);
    });
  });

  group('sendPasswordResetEmail', () {
    test('sets loading, then AsyncData(null) on successful email send (state indicates completion)', () async {
      // Arrange: Current controller logic sets state to data(null) regardless of prior state.
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser)); // Start logged in
      await container.pump(); 

      when(mockAuthRepository.sendPasswordResetEmail(tEmail)).thenAnswer((_) async {});

      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1); 

      // Act
      await authControllerNotifier.sendPasswordResetEmail(tEmail);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, const AsyncData<firebase_auth.User?>(null)), // Controller specific behavior
      ]);
      verify(mockAuthRepository.sendPasswordResetEmail(tEmail)).called(1);
      // The state being AsyncData(null) is the controller's way of signaling completion here.
      expect(container.read(authControllerProvider), const AsyncData<firebase_auth.User?>(null));
    });

    test('sets state to AsyncError on repository failure for sendPasswordResetEmail', () async {
      reinitializeContainerAndController(authStateStream: Stream.value(mockFirebaseUser)); 
      await container.pump();

      final exception = Exception('Failed to send password reset via repo');
      when(mockAuthRepository.sendPasswordResetEmail(tEmail)).thenThrow(exception);
      
      final listener = arrangeListener();
      verify(listener(any, AsyncData<firebase_auth.User?>(mockFirebaseUser))).called(1);

      // Act
      await authControllerNotifier.sendPasswordResetEmail(tEmail);

      // Assert
      verifyInOrder([
        listener(any, const AsyncLoading<firebase_auth.User?>()),
        listener(any, isA<AsyncError<firebase_auth.User?>>().having((e) => e.error, 'error', exception)),
      ]);
      expect(container.read(authControllerProvider).error, exception);
    });
  });
}

// Helper class to listen to provider changes and verify sequence
class Listener<T> extends Mock {
  void call(T? previous, T next);
}

// IMPORTANT:
// 1. Make sure you have `mockito` and `build_runner` in your `dev_dependencies` in `pubspec.yaml`.
// 2. Run `flutter pub get`.
// 3. Run `flutter pub run build_runner build --delete-conflicting-outputs` in your terminal.
//    This will generate the `auth_controller_test.mocks.dart` file.
// 4. Review all test cases, especially the expected state transitions and mock setups,
//    to ensure they perfectly align with your `AuthController`'s exact implementation details
//    and the behavior of your `authRepositoryProvider` and `authStateChangesProvider`.

 