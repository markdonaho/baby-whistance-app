import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'app_status_service.g.dart';

// Enum for guessing status
enum GuessingStatus {
  open,
  closed,
  revealed,
}

// Model for application status
class AppStatus {
  final String id; // Typically a fixed ID like 'current_status'
  final GuessingStatus guessingStatus;
  // final Map<String, dynamic>? actualBabyDetails; // For future use

  AppStatus({
    required this.id,
    required this.guessingStatus,
    // this.actualBabyDetails,
  });

  factory AppStatus.fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    final data = snapshot.data();
    if (data == null) {
      // Return a default status if the document doesn't exist or is empty
      return AppStatus(id: snapshot.id, guessingStatus: GuessingStatus.closed);
    }
    
    
    GuessingStatus status;
    final rawStatus = data['guessing_status'] as String?;
    
    if (rawStatus == null) {
      status = GuessingStatus.closed;
    } else {
      try {
        status = GuessingStatus.values.firstWhere(
          (e) => e.toString() == 'GuessingStatus.' + rawStatus,
        );
      } catch (e) {
        status = GuessingStatus.closed; // Default if parsing fails
      }
    }
    

    return AppStatus(
      id: snapshot.id,
      guessingStatus: status,
      // actualBabyDetails: data['actual_baby_details'] as Map<String, dynamic>?,
    );
  }

  // A default status if nothing is found in Firestore
  factory AppStatus.defaults() {
    return AppStatus(id: 'app_config', guessingStatus: GuessingStatus.closed);
  }
}

// Firestore service for app status
@riverpod
FirebaseFirestore appStatusFirestore(AppStatusFirestoreRef ref) {
  return FirebaseFirestore.instance;
}

@riverpod
class AppStatusService extends _$AppStatusService {
  FirebaseFirestore get _firestore => ref.read(appStatusFirestoreProvider);
  // Using a fixed document ID for app status
  static const String _appStatusDocId = 'app_config'; // Changed from 'current_status' to 'app_config' to match README

  @override
  Stream<AppStatus> build() {
    final docRef = _firestore.collection('app_status').doc(_appStatusDocId);
    return docRef.snapshots().map((snapshot) {
      if (snapshot.exists) {
        return AppStatus.fromFirestore(snapshot);
      } else {
        // If the document doesn't exist, return a default status.
        // Optionally, you could create it here with default values.
        return AppStatus.defaults(); 
      }
    }).handleError((error, stackTrace) {
      // Return default status on error as well, or handle more gracefully
      return AppStatus.defaults();
    });
  }

  // Method to update guessing status (example, typically for admin)
  Future<void> setGuessingStatus(GuessingStatus status) async {
    try {
      await _firestore.collection('app_status').doc(_appStatusDocId).set({
        'guessing_status': status.toString().split('.').last,
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));
    } catch (e) {
      rethrow;
    }
  }
}

// Provider for the AppStatus stream
// This will be generated by Riverpod generator as appStatusServiceProvider
// final appStatusProvider = StreamProvider<AppStatus>((ref) {
//   return ref.watch(appStatusServiceProvider.notifier).stream;
// });

// More direct provider for the AppStatus value from the stream
final currentAppStatusProvider = StreamProvider<AppStatus>((ref) {
  final service = ref.watch(appStatusServiceProvider.notifier);
  if (service == null) {
    // This case should ideally not happen if providers are set up correctly
    return Stream.value(AppStatus.defaults()); 
  }
  return service.stream;
}); 